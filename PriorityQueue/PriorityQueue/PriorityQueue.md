### 优先队列：系统资源管理利器

在普通的任务请求中，我们大多时候将任务放进队列中，一个一个的进行排队，但是现在当有一个任务特别紧急时（比如急诊病人），我们希望系统一有空闲就来处理这个任务；或者是任务时间有长有短，但是我们希望能够尽快的处理短的任务，长的任务放到后面处理（这是一种贪心的思想，这样安排的结果会减短所有任务处理的总时间。）

类似的，在系统资源管理的时候，系统调度程序必须在若干进程中决定运行哪个进程，且每个进程的优先级，所请求的时间不一致，因此为了更高效的处理进程，大多数的系统都使用**优先队列（Priority queue）**作为任务管理的方式。

优先队列大多数采用堆结构实现，这并不是什么必须做的，只是堆这种极其雅致的结构，时间和空间复杂度都能够符合要求，且理解和编写都不算太难，因此我在本次的实验中也采用了两种堆（分别是二叉堆和左式堆）去实现优先队列。

### 二叉堆

堆是一颗完全二叉树，堆的实现由我们定义在其上面的两种性质作为基础。

#### 结构性质

堆是一颗满的二叉树，可以使用数组实现，在堆数据结构中将由一个（Comparable对象的）数组和一个代表**当前堆的大小的整数**组成。 

#### 堆序性质

由于想要快速地找出最小元，因此最小元应该在根上，如果考虑任意子树也应该是堆，那么**任意结点就应该小于它的后裔。**

### 左式堆

为了实现以 $o(N)$ 的时间处理一个合并的操作，对于普通的堆，使用数组管理，合并相当于把一个数组拷贝到另一个数组中去，对于相同大小的堆，这个操作的时间消耗为 $\Theta(N)$。正因为如此，所有支持有效合并的高级数据结构都需要使用链式数据结构。

**左式堆（ leftist heap）**像二叉堆那样既有结构性质，又有堆序性质。与二叉树唯一的区别在于，左式堆不是理想平衡（perfectly balanced），而且事实上是趋于非常不平衡的。

左式堆定理：在右路径上有$r$个结点的左式树必然至少有$2^{r} - 1$个结点。

> $N$个结点的左式树有一条右路径最多含有$\lfloor \log_2{N+1} \rfloor$个结点。

#### 零路径长

我们把任一节点 X 的零路径长定义为从 X 到一个不具有两个儿子的结点的最短路径长。

#### 左式堆性质

左式堆上其实只需要考虑合并操作，因为我们可以把左式堆的插入看成是与一个只有一个元素的树进行合并。

合并定义为，如果这两个堆中有一个堆是空的，那么可以返回另外一个堆，否则，为了合并这两个堆，需要比较他们的根，首先，递归的将具有大的根值的堆与具有小的根值的堆的右子堆进行合并（递归结束的终点为某个堆成为单一结点）

而且，在合并之后虽然堆满足堆序性质，但是并不满足左式堆性质，因此我们还要在递归出口去判断是否是左式的，不是则要交换其左右儿子，新的零路径长是新的右儿子的零路径长+1.

### 测试与效率分析

#### 测试

1. 首先我测试了两种堆的Validation，确保结构实现没有错误，初步保证之后的较大数据的测试的稳定性。

2. 对于两种堆的 insert( ) 操作，我分别使用了1E7的数据，将近400M的文件输入进行了对比测试，测试结果如下。

   ![图片](http://i1.piimg.com/567571/99c279405958fcdf.png)

   ![图片](http://p1.bqimg.com/567571/999eade7dba70c68.png)

3. 接下来，对两种堆的合并merge( )函数进行了对比测试，测试结果如下。

   ![图片](http://p1.bqimg.com/567571/1d53d9e91136138f.png)

   ​

#### 结果分析

1. 对于插入的效率是显然的，堆中的PercolateDown( ) 函数可以在 $\Theta(\log_2{N})$ 的时间里完成从头结点到儿子结点的堆的结构更新，而左式堆中的merge( ) 函数可以在最坏$O(\log_2{N})$的时间内完成递归终止，同时也会消耗$O(\log2_{N})$的栈空间。

   而在LeftistHeap中，插入要比Heap慢上些许，我想可能是因为LeftistHeap的实现是基于链式二叉树结构，动态分配大量空间的时候效率不如Heap的静态一次分配高。

2. 对于合并，显然合并两个相同大小的 Heap 其时间复杂度为 $O(N*\log_2{N})$ 的，但是 LeftistHeap 确是在最坏$\Theta(\log_2{N})$ 完成这个操作，但同样，LeftistHeap 也需要使用$\Theta(\log_2{N})$的辅助栈空间。

   所以时空的交换大多是Trade off，很难有两方面都最优化的解。

### 学以致用：Application

1. 首先堆的应用便是如在测试中所作的那样，去维护一大堆数据的有序性，在测试部分已经给出了其效率的展示。

2. Top k 问题

   >  在大规模数据处理中，经常会遇到的一类问题：在海量数据中找出出现频率最好的前k个数，或者从海量数据中找出最大的前k个数，这类问题通常被称为top K问题。例如，在搜索引擎中，统计搜索最热门的10个查询词；在歌曲库中统计下载最高的前10首歌等。
   >
   >  针对top K类问题，通常比较好的方案是分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树或者是Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数，最后在所有top K中求出最终的top K。

   对于Top k问题，如果去暴力排序，或者是$O(N)$时间建堆，对于上百亿规模的N，无论是搜索效率或者是空间开销都是难以接受的。

   在上面的引用部分给出了当前流行的实现方式，但是我自己也接触过一种稍微简单一点，更易编程实现的Top k问题的解决方式。

   https://leetcode.com/problems/kth-largest-element-in-an-array/#/description

   这是 Leetcode 上一道典型的 Top k 的问题。

   我们如果要找出前 K 个最大的元素，使用最小堆结构，我们只需要去维护一个含有 K 个最大元素的集合 S ，在前K个元素读入以后直接建堆花费 $O(k)$ 的时间，当再读入一个新的元素 $e$ 时，我们将该元素 $ e$ 与第 k 个最大元素 $S_k$ 进行比较，如果 $e$ 小于 $S_k$ ，则 $e$ 会直接被扔掉，如果 $e \gt S_k$，那么将会最多耗费 $O(\log_2{K})$ 的时间。

   因此总的时间复杂度为$O(k + (n-k) * \log_2{k})$.

   ##### 测试：

   ![图片](http://p1.bpimg.com/567571/548b3b5e76fd8dc6.png)

   测试结果说明，使用第二种方法优化的查询 Top k 不仅内存的空间效率远胜第一种，而且时间效率也不逊色，表现极为优异。

   ​

### 他山之石：Reference

1. zyq522376829 (2015). "*海量数据处理 - 10亿个数中找出最大的10000个数（top K问题）* ". Retrieved on 14th March, 2017 from:

   http://doc.okbase.net/zyq522376829/archive/169290.html

2. Cormen, Thomas H.; Leiserson, Charles E.; Rivest, Ronald L.; Stein, Clifford (2009) [1990]. " *Introduction to Algorithms (3rd ed.)* ". MIT Press and McGraw-Hill. ISBN 0-262-03384-4.