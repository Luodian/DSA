# 为什么最短路算法看起来都如此相似？

### 一、综述

**最短路径问题**的重要性几乎不言而喻，每一个人都应该能感受到最短路问题的存在，从野生世界中的蚁群回巢，实际生活中的高德地图寻路，到虚拟世界的网络信息传输，都广泛的应用了最短路径算法。

最短路径问题大致分为以下几种：

1. **确定起点的最短路径问题** - 即已知起始结点，求最短路径的问题。
2. **确定终点的最短路径问题** - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。
3. **确定起点终点的最短路径问题** - 即已知起点和终点，求两结点之间的最短路径。
4. **全局最短路径问题** - 求图中所有的点对之间的最短路径。

下面我们从看似最简单的但是却背后隐藏着动态规划思想的 Floyd 算法开始。

### 二、Floyd算法

**Floyd-Warshall算法**（英语：Floyd-Warshall algorithm），中文亦称**弗洛伊德算法**，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。

Floyd 的原理是动态规划，设$D_{i,j,k}$ 为从 $i$ 到 $j$ 的只经过以 $(1 \ldots k)$ 集合中的结点为中间结点的最短路径。

1. 若最短路径经过 k ，则 $D_{i,j,k} = D_{i,k,k-1} + D_{k,j,k-1}$
2. 若最短路径不经过点 k，则 $D_{i,j,k} = D_{i,j,k-1}.$

因此$D_{i,j,k} = min\{ D_{i,k,k-1} + D_{k,j,k-1} , D_{i,j,k-1} \}$，我们不用存 k-1的状态，因此可以使用递推的方式，将空间使用率降低为二维。

#### 时空复杂度分析（Complexity）

显然在迭代的过程中我们需要对 $i,j,k$ 三维的状态变量进行递推的枚举，因此时间复杂度为$O(N^{3})$，而辅助空间复杂度为$O(N^{2})$.

> 这一点在使用领接矩阵和领接表时并没有什么区别，因为我们即使使用领接表，也需要一个辅助的矩阵来存当前状态下的 $dist(i,j)$



#### 实现（Implement）

```cpp
void update()
{
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= n; ++j)
		{
			Asist[i][j] = 0;
            if (Gm[i][j])
            {
            	dp[i][j] = Gm[i][j];
            }
            else
            {
            	dp[i][j] = INF;
            }
		}
	}
	for (int k = 1; k <= n; ++k)
	{
		for (int i = 1; i <= n; ++i)
		{
			for (int j = 1; j <= n; ++j)
			{
				if (dp[i][j] > dp[i][k] + dp[k][j])
				{
					dp[i][j] = dp[i][k] + dp[k][j];
					Asist[i][j] = k;
				}
			}
		}
	}
}
```
### 三、Djikstra算法

Dijkstra算法是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决赋权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。

#### 算法思想

这个算法是通过为每个顶点 $v$ 保留目前为止所找到的从 $s$ 到 $v$ 的最短路径来工作的。初始时，原点 $s$ 的路径权重被赋为 0 $（d[s] = 0）$。若对于顶点 $s$ 存在能直接到达的边$（s,m）$，则把 $d[m]$ 设为 $w（s, m）$,同时把所有其他（ $s$ 不能直接到达的）顶点的路径长度设为无穷大，即表示我们不知道任何通向这些顶点的路径（对于所有顶点的集合 *V* 中的任意顶点 *v*， 若 *v* 不为 *s* 和上述 *m* 之一， *d[v]* = ∞）。当算法结束时，*d[v]* 中存储的便是从 *s* 到 *v* 的最短路径，或者如果路径不存在的话是无穷大。

![](http://i2.muimg.com/567571/b5dfd39ad0a68289.gif)

#### 时空复杂度分析（Complexity）

对于朴素dijikstra算法，其在每一步更新路径的时候，去搜索当前顶点集 V 中最近的点，都需要遍历一次顶点集，因此其时间复杂度为$O(N^{2})$（领接矩阵存图），$O(N * M)$ （领接表存图）。

对于堆优化的情况，我们在搜索当前顶点集中最近的点，只需要去维护一个```pair<dist[i],i>```的堆即可，每次出堆的头结点，头结点即离当前集合最近的一个可拓展点，因此我们使用二叉堆时算法的时间复杂度为$O((m + n) * \log_{2}N)$，如果使用斐波拉契堆，算法的时间复杂度可以被优化到 $O(m + n*\log_2{N})$.

当然也不能忘记，如果要使用堆，在空间复杂度上也会多一个$O(N)$的辅助空间。

#### 关于负权值的讨论

对于这个算法，其相比SPFA最大的劣势就是在于其对于负权值以及负环路的处理上存在着缺陷。

这个分析我认为要分两种实现方式，首先是朴素版本。

1. 我们已知Djikstra算法是基于贪心思想的，它只能看到当前最优解，却不能看到远处经历过一次负权值路径之后的最优解，因此只要出现负权值，这个算法就会出现错误。

   ![](http://i2.muimg.com/567571/3eb9e21d0420d1af.png)对于上图的情况，我们在一开始选定dist的时候，就已经将 dist[3] 赋值为 2，dist[2] 赋值为 3，然后选定最		 短的相邻点为 3，将其标记进入$V$集合，因此我们下次再想要通过 dist[2] + graph\[2\][3] < dist[3] 来松弛 dist[3] 的时候，由于我们之前的贪心策略已经告诉我们 $3$ 已经加入了点集 $V$ ，且通过路径 $1\rightarrow3$ 到达，然后更新结束，我们会得到一个错误的答案，本来应该是通过$1 \rightarrow 2 \rightarrow 3$ 权值为3 - 2 = 1的路径的，但是最终的结果却是 $1 \rightarrow 3$ ，最终权值为 2.

接下来是对于堆优化版本的分析。

2. 堆优化版本还要分为两种写法来进行分析：

   首先最重要的是！！！我们要明白堆里存的是```pair<cur,dist[cur]>```，而这个的第二维 dist[cur] 就是引起可能会出现的死循环的原因所在。

   - 不允许重入队

     每次访问结点 cur 将 vis[cur] 标记为1，因此这种写法可以避免负环的存在而引起的死循环的，但是这种做法和上面的朴素算法相同，是不能够正确的计算出正确的值。


-    允许重入队

     这种写法下，结点 cur 被弹出优先队列之后 vis[cur]会被还原为 0，这种情况下就可以在存在负权值的情况中完成正确的计算。

     但是这种情况下，如果图中存在负环的情况下，则会因为```pair<i,dist[i]>```中的 dist[i] 绕一圈后圈上的dist[]会被更新的越来越小，而不断地进行入队的操作，最终优先队列会爆掉上限。

     而实际上这种方式已经无限的接近于了可以处理负环的SPFA算法，下面会对SPFA算法进行一定的简述。

### 四、SPFA算法

#### 算法思想

该算法基于Bellman-ford算法队列版本的优化而来，它减少了Bellman-ford算法中每次对于n个结点的松弛操作，因为它只知道要求单源最短路，至多做n次松弛操作即可获知最短路

SPFA 在形式上和宽度优先搜索非常类似，不同的是宽度优先搜索中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进，于是再次用来改进其它的点，这样反复迭代下去。设一个点用来作为迭代点对其它点进行改进的平均次数为k，有办法证明对于通常的情况，k在2左右，k为每个点平均的入队次数。

而SPFA能够判断负环也是基于一个已知定理：**如果某个点进入队列的次数超过N次则存在负环，因为负权环可以无限制的降低总花费，所以如果发现第 $n$ 次操作仍可降低花销，就一定存在负权环**。

因此我们只用对于每个点的入队次数进行一个计数即可判断是否存在负环。

#### 时空复杂度分析（Complexity）

SPFA的算法相比与Bellman-ford算法，其时间复杂度可以降低到 O(kE)，k是个比较小的系数(每个点平均的入队次数，并且在绝大多数的图中，k<=2，然而在一些精心构造的图中可能会上升到很高)

空间复杂度则是需要一个 $O(N)$ 的队列作为辅助空间。

> 大部分的算法其实都是时间和空间的一种Trade off.

#### 更多优化（Want for more）

SPFA算法有两个优化算法 SLF 和 LLL： SLF：Small Label First 策略，设要加入的节点是j，队首元素为i，若dist(j) \< dist(i)，则将j插入队首，否则插入队尾。 LLL：Large Label Last 策略，设队首元素为i，队列中所有dist值的平均值为x，若 dist(i) > x则将 i 插入到队尾，查找下一元素，直到找到某一 i 使得 dist(i) <= x，则将 i 出对进行松弛操作。 SLF 可使速度提高 15 ~ 20%；SLF + LLL 可提高约 50%，而我们实际操作时为了简化，SLF的操作也可以直接使用优先队列来替代队列。

> 所以呢！！这就是Djikstra的堆优化的一种变种啊，最短路算法背后的实现方法原来都是相互交错的。

#### 应用（Application）

其实对于 SPFA 算法，其只在平均情况下效率高于 Djikstra 算法，实际操作不如 Djikstra 算法稳定，因此我们在应用 SPFA 算法的时候更倾向于使用它的可以处理负环路的这一特性。

对于在最短路过程中可能会出现负环路的情况，实际应用中有一种差分约束系统的问题是可以抽象成带负权值的最短路的。

### 五、测试（TEST）

1. 小数据

2. 稠密图（Djikstra和Floyd的比较）

   对于一个100个顶点， 6234条边的近似完全图，我们使用两种算法的运行结果分别如下：

   ```cpp
   2. Dense graph test

   Djikstra :
   The shortest path cost: 103.
   The time efficiency: 0.00924 s.

   Floyd :
   The shortest path cost: 103.
   The time efficiency: 0.010082 s.

   ```

   可以见得，在边稠密图的情况下，点相对较少，这时像是 floyd 这种基于点松弛的算法无论是在时间还是空间（领接矩阵存储），都不占劣势，而且还有一个优势则是其编程实现极为简单。

3. 大数据（Djikstra和SPFA的比较）

   对于一个100000个顶点，4998748条边的图，因为矩阵基本上已经没法存了，这个矩阵至少得10G的内存空间。所以我们应用了两种基于领接表存储的算法来进行速度上的测试。

   ```cpp
   Djikstra :
   The shortest path cost: 278.
   The time efficiency: 5.97105 s.

   SPFa :
   The shortest path cost: 278.
   The time efficiency: 5.9119 s.
   ```

   同样可以见得，Djikstra 相对于 SPFA 虽然理论上最坏时间复杂度要高于后者的期望时间复杂度，但是对于我们给定的数据并不占下风，而且在实际的应用中SPFA的算法时间效率不是很稳定，为了避免最坏情况的出现，通常使用效率更加稳定的Dijkstra算法。

   > 如果对于差分约束系统等模型，必须要要求负权值的出现，则只能选用SPFA，因此各种算法其实都需要熟练地掌握才能够游刃有余的解决问题。

