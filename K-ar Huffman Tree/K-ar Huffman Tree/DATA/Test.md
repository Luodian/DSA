# 浅谈DFS && BFS

搜索，是应用算法去解决复杂问题的第一个门槛，搜索可以说是最基础却又是应用最广泛的算法。我们应用搜索算法可以从简单的显示图寻找路径，到复杂的解空间的状态搜索，剪枝优化，迭代加深搜索等等更复杂的搭配与应用。

而本周主要从最简单的图，树上的搜索开始。

### DFS：走走走，不撞南墙不回头

DFS 在于从一个初始状态出发，一直转移状态直到搜到目标或搜到状态无法进行转移为止，而其中的剪枝便是通过应题目具体要求和仔细分析而去掉某些没必要或不存在的状态以节约时间和空间。 

- 思想： 一直往深处走，直到找到解或者走不下去为止。

  走：dfs(next), 下一个next是哪里？

  南墙：递归终止条件，在哪里return？

- 简单应用：

  -  树的先序中序后序遍历

     ![](http://i4.buimg.com/588926/40b57e826ab994da.png)

  - 迷宫求解

     ![](http://www.mathmaniacs.org/lessons/11-graphsearch/maze.gif)

  ​

### BFS：东瞧瞧细看看

BFS在于一层一层地扩展状态，这样首先找到的目标便一定是用时或步数最少的。

- 思想：从初始状态S开始，利用规则，生成下一层的状态，顺序检查下一层的所有状态，看是否出现目标状态G，否则就对该层所有状态节点，分别利用规则。生成再下一层的所有状态节点，继续按上面思想生成再下一层的所有状态节点，这样一层一层往下展开。直到出现目标状态为止，相当于按层次的顺序来遍历搜索树。

  东瞧瞧西看看指的是？

  指的是在当前结点时，直接枚举可以到达的所有结点，全部加入到这个队列中当前结点的后面。

- 简单应用：

  -  树的层序遍历

     见上图

  - 迷宫问题（最少步数走到指定位置）

     当题目中出现『最少步数』这种词语，优先考虑 BFS。

  > DFS几乎适用于所有情况，因为这本身是一种遍历所有状态的搜索，只不过在寻找最小步或最小时间的情况下比较慢，无法快速找到目标，但在程序世界里DFS本身也有不适用的情况，如果状态没有下限即转移的深度没有下限那么便无法深搜。
  >
  > 同样，BFS也可能存在一层状态都扩展不完的情况，这样便才会有迭代加深搜索等扩展搜索的出现，它结合了两者的优点且实际应用效果不错，而实际应用，比如爬虫当中，我们通常都是结合BFS和DFS的优点，根据一个评价函数（如启发式测度函数），在目前产生的所有结点中选择具有最小评价函数的结点进行拓展，尽可能考虑全局最优解。


### 状态转移与解答树

说起状态转移，其实这是一个很终极的问题，很多题目，问题，都可以表示成状态，并且通过不断的进行状态转移，去得到我们想要的解。搜索与DP，贪心，分治的共同点在于状态的转移，只不过在搜索中，一个阶段的最优状态是由之前所有状态得到的，这是其余其他算法的区别之处。

![](http://i4.buimg.com/588926/5fbced3feff75083.gif)



这一部分主要是需要考虑的状态的表示以及状态的转移，本质其实就是在解空间搜索一个可行的解。

应用：

倒水问题，八皇后问题，八数码问题等。

### 关于题目

怎么入手DFS && BFS类型题目

1. 怎么表示状态？
2. 如何进行状态的转移？
3. 是否需要标记已经转移过的状态以及怎么标记已经转移过的状态以不重复转移，你不能单一地判断，要综合所给的题中所有出现的变化，在这个阶段中，我标记这个阶段时的状态，因为很可能不止“你”在变化，图中的情况也在变化。
4. 怎么去除没必要的或不存在的状态（剪枝），因为有些状态是不需要进行转移或扩展的。


### 题解

##### A题

『题意』

求一个油田的连通块的个数，注意是8个方向连通。

『分析』

简单的DFS或者BFS可解，入门级别题目，但是要注意BFS时在哪一步进行标记已访问，不然有可能会造成队列过长而MLE。

##### B题

『题意』

有一个电梯，每层楼的按钮上标记着 $K_i$ ，每层楼 $i$ 只能到达 $i \pm K_i$ 层，现在给出起点楼层 $A$，终点楼层 $B$，问最少走多少步能够从 $A$ 走到 $B$.

『分析』

这个题目我们应该使用 BFS ，每次拓展上下两个结点，每次拓展 step + 1.

这个题为什么直接一次 BFS 就可以呢？因为 BFS 本质是检查一层的所有状态，因此如果找到解，那么一定是所用步骤最少的解。

为什么不能用 DFS ？如果我们想要找到最少的步数，那么就得考虑，首先是 DFS 的方向，向上还是向下呢？不好确定，但是如果不确定，恩~那 DFS 就比 BFS 要慢上很多了，因为它会尝试十分多的 Wrong Ways.

##### C题

『题意』

在一个棋盘上，给出起点和终点，求骑士从起点走到终点所用的最少步数，注意骑士是走日字的~

![2011091919380232](/Users/luodian/Desktop/2011091919380232.jpg)

『分析』

仍然是一道 BFS 题目，关键词是「最少步数」。

##### D题

『题意』

此题题意为给定棋盘的形状（可以放的位置），求在当前形状下可以按照规则放置棋子的情况种数（同一行同一列不能同时放置两个棋子）。

『分析』

本质上是有约束条件的N皇后问题，我们可以从行（ row ）开始进行 DFS，使用一个 vis[] 数组去判断当前列（ col ）是否已经访问过。

同时这是一个找方案种数的问题，对于这种问题，我们不仅是要找到解，还要知道能够找到多少种解，因此枚举列之后我们需要还原枚举状态（如果不还原，会造成一次找到解函数就结束递归）。

##### E题

『题意』

对树进行染色，要求是一个结点的与它的两个相邻结点颜色不能一样，求最少的需要的颜色数量以及求一种可行的染色方式。

『分析』

可以通过观察分析得到，最少需要的颜色数量为 maxDegree + 1，然后染色的方式就是，随便找一个点开始dfs。过程中，记录当前结点与当前结点的父亲

```cpp
void dfs(int cur,int father);
```

先将当前结点的儿子挨个染色，保证颜色各不相同且与当前结点以及其父亲均不相同，一遍dfs访问完所有的点即可。

##### F题

『题意』

现在屏幕上有一个烟花，给出一些时间，烟花一开始向上绽放，到达时间节点会不断的由$45^{\circ}$方向向外散射（具体见图），问在给定的时间节点下，烟花会绽放到最多多少格子？

『分析』

其实可以看成是对于结点的 BFS，到达时间结点就开始按照方向拓展，将可以散射方向的结点加入队列。

这个思路比较好想，但是实现起来较为复杂。

这里推荐可以用

```cpp
set<pair<int,int>>
```

进行判重，因此不用建图。

还可以用

```cpp
bitset<8> bar(string("10000000"))	
```

来表示方向，一共有8个方向，对于每位的 1 表示当前结点可以朝着这个方向拓展，0 则不可以，这样表示的好处在于，可以很方便的对两个 bitset 类型的元素进行合并，利用并操作即可。

```cpp
 #include <bitset>
//需要引入这个头文件
  std::bitset<4> foo (std::string("1001"));
  std::bitset<4> bar (std::string("0011"));
  std::cout << (foo|bar) << '\n';        
  //ans =  1011
```

##### G题

『题意 + 分析』

这道题没有那么困难，如果发现了一些其中奥秘，直接DFS输入建图，BFS 输出即可。

##### H题

『题意 + 分析』

首先计算每个子树的最大最小权重以及当前权重，子树的最小权是每个邻接子树最小权的和再加上所有出边减小到最小之后的权$min_x = \sum(min_y + w_{x,y} - min(p_{x,y} - min_y , w_{x,y} - 1))$，y为所有x邻接的子树根顶点，p为边的力量，w为边的权重。

子树的最大权是每个邻接子树最大权的和再加上所有出边权，另外最大权不能超过入边的力量 $max_x = min(p_{z,x},\sum{max_y + w_{x,y}})$，p为x入边的力量.

当前权重即为所有邻接子树的当前权重加上所有出边权$weight_x = \sum(weight_y+w_{xy})$这些可以用一次dfs求出，如果求值过程中发现某个顶点子树最小权重超过入边力量，则无解，输出 -1。

接下来要将整个树的总权重降低到 $max_1$ ，可以证明贪心的优先减小远离根顶点的边的权重总是更优

定义 $reduce_x$ 为子树所需要减小的权重，所以首先$reduce_1 = weight_1 - max_1$接下来进行先序dfs，把每个顶点的权重减小目标转移到出边连接的子树上，首先对于每个出边连接的顶点y，将$weight_y - max_y$的目标转移到y上，如果当前顶点的目标依然不为0，则再将$min(reduce_x,max_y-min_y)$的目标转移到y上，如果目标还不为0，再减小出边的权重直到目标为0，这些可以用一次dfs求出。

整个解法一共2次dfs，时间复杂度O(n)。

##### I题

『题意 + 分析』

随便选定一个顶点作为根，将树转换为有向树，定义$f(u)$为以$u$的子树中被选中的顶点个数，寻找一个顶点$v$使得$f(v) \geq k$，并且对于 $v$ 的所有邻接子树 $u$ 有$f(u) \leq k$，寻找的方法如下：

从根顶点开始向下走，始终走向$f(v) \geq k$的顶点，直到某个顶点没有满足的出边，这个顶点即为所求的顶点$v$

以$v$为根重新建立有向树，此时$v$的所有邻接子树内被选中的顶点数都小于等于$k$

题目所求的$m$恒为1，所有队伍都可以居住于同一城市，并且这个城市就是$v$

建立一个数组a，从 $v$ 开始dfs，依次将 $v$ 每个邻接子树里面的所有被选中的顶点放入a，如果 $v$ 也被选中则将 $v$ 放到最后，按照(a[1],a[1+k]),(a[2],a[2+k]),(a[3],a[3+k])…的方式分配k对顶点，因为 $v $的每个邻接子树里被选中的顶点个数都小于等于k，所以每对顶点都处于不同的子树中，它们之间的最短路一定经过 $v$，即为符合题意的分配。







